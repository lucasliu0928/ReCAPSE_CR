HCUP_Diag2_df$CODE_TYPE <- "ICD10_Diag"
HCUP_Proc1_df$CODE_TYPE <- "ICD9_Proc"
HCUP_Proc2_df$CODE_TYPE <- "ICD10_Proc"
HCUP_comb <- rbind(HCUP_Diag1_df[,c("Code","CCS.CATEGORY","CCS.CATEGORY.DESCRIPTION","CODE_TYPE")],
HCUP_Diag2_df[,c("Code","CCS.CATEGORY","CCS.CATEGORY.DESCRIPTION","CODE_TYPE")],
HCUP_Proc1_df[,c("Code","CCS.CATEGORY","CCS.CATEGORY.DESCRIPTION","CODE_TYPE")],
HCUP_Proc2_df[,c("Code","CCS.CATEGORY","CCS.CATEGORY.DESCRIPTION","CODE_TYPE")])
length(unique(HCUP_comb$CCS.CATEGORY)) #276
View(HCUP_comb)
chuback_group_df[,"Code"]<- clean_code_func(chuback_group_df[,"Code"])
Ritzwoller_group_df[,"Code"] <- clean_code_func(Ritzwoller_group_df[,"Code"])
HCUP_comb[,"Code"]  <- clean_code_func(HCUP_comb[,"Code"])
HCUP_comb[,"CCS.CATEGORY"]  <- clean_code_func(HCUP_comb[,"CCS.CATEGORY"]) #Clean category in HCUP
month_data <- read.csv(paste0(outdir, "diag_monthly_df.csv"))
month_data <- month_data[,-5] #remove Na code columns
length(unique(month_data$ID)) #510
nrow(month_data) #39180
table(month_data$outcome)
#remove all NA columns
month_data <- month_data[,-which(sapply(month_data, function(x)all(is.na(x)))==T)]
colnames(month_data)
proj_dir <- "/Users/lucasliu/Desktop/DrChen_Projects/ReCAPSE_Project/"
data_dir <- paste0(proj_dir,"/ReCAPSE_Intermediate_Data/0318_21/For_Both_Data/")
month_data <- read.csv(paste0(data_dir, "diag_monthly_df.csv"))
month_data <- month_data[,-5] #remove Na code columns
length(unique(month_data$ID)) #510
nrow(month_data) #39180
View(month_data)
table(month_data$outcome)
#remove all NA columns
month_data <- month_data[,-which(sapply(month_data, function(x)all(is.na(x)))==T)]
colnames(month_data)
proj_dir <- "/Users/lucasliu/Desktop/DrChen_Projects/ReCAPSE_Project/"
data_dir <- paste0(proj_dir,"/ReCAPSE_Intermediate_Data/0318_21/For_Both_Data/")
month_data <- read.csv(paste0(data_dir, "diag_monthly_df.csv"))
month_data <- month_data[,-5] #remove Na code columns
length(unique(month_data$ID)) #510
nrow(month_data) #39180
table(month_data$outcome) #0:1985309, 1:110121
View(month_data)
length(month_data)
j <-4
curr_col <- month_data[,j]
curr_col
which(curr_col > 1)
which(curr_col == 1)
length(which(curr_col == 1))
length(which(curr_col > 1))
length(which(curr_col >= 1))
n_pts <- which(curr_col >= 1) #n of pts have at least one code in this group
n_pts
perc_pts <- n_pts/nrow(month_data)
perc_pts
n_pts
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts <- n_pts/nrow(month_data)
perc_pts
#Select the groups that match or exceed the threshold of the fraction of patients with at least one code in that group;
#the nonrecurrent patient thresholds are 0.15, 0.15, and 0.05,
#and the recurrent patient thresholds are 0.10, 0.10, and 0.01 for the diagnostic, procedure, and drug groups
perc_pts <- NA
for (j in 1:length(month_data)){
curr_col <- month_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(month_data)
}
perc_pts <- NA
for (j in 4:length(month_data)){
curr_col <- month_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(month_data)
}
perc_pts
which(perc_pts > 0.2)
which(perc_pts > 0.01)
which(perc_pts > 0.1)
which(perc_pts > 0.15)
nonrecurrent_pts_data <- month_data[which(month_data$outcome == 0),]
recurrent_pts_data <- month_data[which(month_data$outcome == 1),]
perc_pts <- NA
analysis_data <- recurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
which(perc_pts > 0.10)
recurrent_pts_data <- recurrent_pts_data[,which(perc_pts > 0.10)]
View(recurrent_pts_data)
proj_dir <- "/Users/lucasliu/Desktop/DrChen_Projects/ReCAPSE_Project/"
data_dir <- paste0(proj_dir,"/ReCAPSE_Intermediate_Data/0318_21/For_Both_Data/")
month_data <- read.csv(paste0(data_dir, "diag_monthly_df.csv"))
month_data <- month_data[,-5] #remove Na code columns
length(unique(month_data$ID)) #510
nrow(month_data) #39180
table(month_data$outcome) #0:1985309, 1:110121
nonrecurrent_pts_data <- month_data[which(month_data$outcome == 0),]
recurrent_pts_data <- month_data[which(month_data$outcome == 1),]
#Select the groups that match or exceed the threshold of the fraction of patients with at least one code in that group;
#the nonrecurrent patient thresholds are 0.15, 0.15, and 0.05,
#and the recurrent patient thresholds are 0.10, 0.10, and 0.01 for the diagnostic, procedure, and drug groups
perc_pts <- NA
analysis_data <- recurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
recurrent_pts_data <- recurrent_pts_data[,c(1,2,3,which(perc_pts > 0.10))]
perc_pts <- NA
analysis_data <- nonrecurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
nonrecurrent_pts_data <- nonrecurrent_pts_data[,c(1,2,3,which(perc_pts > 0.15))]
which(perc_pts > 0.15)
nonrecurrent_pts_data <- nonrecurrent_pts_data[,c(1,2,3,which(perc_pts > 0.10))]
nonrecurrent_pts_data <- month_data[which(month_data$outcome == 0),]
recurrent_pts_data <- month_data[which(month_data$outcome == 1),]
Select the groups that match or exceed the threshold of the fraction of patients with at least one code in that group;
#the nonrecurrent patient thresholds are 0.15, 0.15, and 0.05,
#and the recurrent patient thresholds are 0.10, 0.10, and 0.01 for the diagnostic, procedure, and drug groups
perc_pts <- NA
analysis_data <- recurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
recurrent_pts_data <- recurrent_pts_data[,c(1,2,3,which(perc_pts > 0.10))]
View(recurrent_pts_data)
perc_pts <- NA
analysis_data <- nonrecurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
nonrecurrent_pts_data <- nonrecurrent_pts_data[,c(1,2,3,which(perc_pts > 0.05))]
View(nonrecurrent_pts_data)
comb_filtered_data <- rbind(recurrent_pts_data,nonrecurrent_pts_data)
View(comb_filtered_data)
nonrecurrent_pts_data <- month_data[which(month_data$outcome == 0),]
recurrent_pts_data <- month_data[which(month_data$outcome == 1),]
#Select the groups that match or exceed the threshold of the fraction of patients with at least one code in that group;
#the nonrecurrent patient thresholds are 0.15, 0.15, and 0.05,
#and the recurrent patient thresholds are 0.10, 0.10, and 0.01 for the diagnostic, procedure, and drug groups
perc_pts <- NA
analysis_data <- recurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
recurrent_pts_data <- recurrent_pts_data[,c(1,2,3,which(perc_pts > 0.05))]
which(perc_pts > 0.05)
perc_pts <- NA
analysis_data <- nonrecurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
nonrecurrent_pts_data <- nonrecurrent_pts_data[,c(1,2,3,which(perc_pts > 0.05))]
which(perc_pts > 0.05)
perc_pts <- NA
analysis_data <- nonrecurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
nonrecurrent_pts_data <- nonrecurrent_pts_data[,c(1,2,3,which(perc_pts > 0.05))]
ccol_indexes1 <- which(perc_pts > 0.05))
ccol_indexes1 <- which(perc_pts > 0.05)
ccol_indexes1
nonrecurrent_pts_data <- month_data[which(month_data$outcome == 0),]
recurrent_pts_data <- month_data[which(month_data$outcome == 1),]
#Select the groups that match or exceed the threshold of the fraction of patients with at least one code in that group;
#the nonrecurrent patient thresholds are 0.15, 0.15, and 0.05,
#and the recurrent patient thresholds are 0.10, 0.10, and 0.01 for the diagnostic, procedure, and drug groups
perc_pts <- NA
analysis_data <- recurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
ccol_indexes1 <- which(perc_pts > 0.05)
perc_pts <- NA
analysis_data <- nonrecurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
ccol_indexes2 <- which(perc_pts > 0.05)
ccol_indexes2
ccol_indexes1
comb_filtered_data <- month_data[,c(1,2,3,ccol_indexes1,ccol_indexes2)]
View(comb_filtered_data)
nonrecurrent_pts_data <- month_data[which(month_data$outcome == 0),]
recurrent_pts_data <- month_data[which(month_data$outcome == 1),]
#Select the groups that match or exceed the threshold of the fraction of patients with at least one code in that group;
#the nonrecurrent patient thresholds are 0.15, 0.15, and 0.05,
#and the recurrent patient thresholds are 0.10, 0.10, and 0.01 for the diagnostic, procedure, and drug groups
perc_pts <- NA
analysis_data <- recurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
ccol_indexes1 <- which(perc_pts > 0.05)
perc_pts <- NA
analysis_data <- nonrecurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
proj_dir <- "/Users/lucasliu/Desktop/DrChen_Projects/ReCAPSE_Project/"
source(paste0(proj_dir,"ReCAPSE_Code/Ultilities.R"))
data_dir <- paste0(proj_dir,"/ReCAPSE_Intermediate_Data/0318_21/For_Both_Data/")
outdir <- paste0(proj_dir,"/ReCAPSE_Intermediate_Data/0318_21/For_Both_Data/")
perday_data <- read.csv(paste0(data_dir,"filtered_inValidMonth_comb_perday_df.csv"),stringsAsFactors = F)
analysis_Ids <- unique(perday_data$study_id)
length(analysis_Ids) #this is the finaly anlyaisi Id who has valid claim month less than "finaly_anlaysi Id file, cuz valid month filtered
################################################################################
### Load outcome
################################################################################
outcome_df <- read.csv(paste0(outdir,"updated_All_event_df.csv"),stringsAsFactors = F)
################################################################################
### Load Valid month
################################################################################
Valid_Month_df <- read.csv(paste0(outdir,"All_Final_Valid_month.csv"),stringsAsFactors = F)
#load group file of codes
diag_df <- read.csv(paste0(data_dir,"Grouped_Diag_codes.csv"),stringsAsFactors = F)
Proc_df <- read.csv(paste0(data_dir,"Grouped_Proc_codes.csv"),stringsAsFactors = F)
Drug_df <- read.csv(paste0(data_dir,"Grouped_Drug_codes.csv"),stringsAsFactors = F)
code_type <- "Diag_Codes"
analysis_df <- diag_df
group_name <- "Chubak_type"
unique_groups <- unique(analysis_df[,group_name])
unique_groups <- unique(unlist(strsplit(unique_groups,split = "$$$$",fixed = T))) #multiple grp situtation
library(lubridate)
month_df_list <- list()
for (i in  1: length(analysis_Ids)){
if (i %% 100 == 0){
print(i)
}
curr_id <- analysis_Ids[i]
curr_perday_df <- perday_data[which(perday_data$study_id ==curr_id ),]
curr_valid_month <- sort(Valid_Month_df[which(Valid_Month_df$ID ==curr_id),"Valid_Month"])
curr_outcome_df <-  outcome_df[which(outcome_df$ID == curr_id ),]
curr_SBCE_flag <- curr_outcome_df$SBCE
curr_SBCE_time <- mdy(curr_outcome_df$Date_2nd_Event)
####
curr_df <- as.data.frame(matrix(NA, nrow = length(curr_valid_month) ,ncol = length(unique_groups) + 3))
colnames(curr_df) <- c("ID","Month_Start","outcome",unique_groups)
curr_df$ID <- curr_id
curr_df$Month_Start <- curr_valid_month
for (j in 1:length(curr_valid_month)){
curr_mon_start <- ymd(curr_valid_month[j])
curr_mon_end <- curr_mon_start + months(1)
curr_month_df<- curr_perday_df[which(ymd(curr_perday_df$claims_date) >= curr_mon_start &
ymd(curr_perday_df$claims_date) < curr_mon_end),]
curr_month_codes <- unlist(strsplit(curr_month_df[,code_type],"$$$$",fixed = T))
#find each codes group
matched_groups <- analysis_df[which(analysis_df$Code %in% curr_month_codes),group_name]
matched_groups <- unlist(strsplit(matched_groups,split = "$$$$",fixed = T))
na_indxes <- which(is.na(matched_groups)==T)
if (length(na_indxes) > 0){
matched_groups <- matched_groups[-na_indxes]
}
count_tb <- as.data.frame(table(matched_groups))
df_indxes <- which(colnames(curr_df) %in% count_tb[,1])
curr_df[j,df_indxes] <- count_tb[,"Freq"]
#print(df_indxes)
#add outcome
if (curr_SBCE_flag == 0){
curr_df[j,"outcome"] <- 0  #"Pre"
}else{
#compare if curr month before or after SBCE
if (curr_mon_start < curr_SBCE_time){
curr_df[j,"outcome"] <- 0  #0
}else{
curr_df[j,"outcome"] <- 1 #post
}
}
}
month_df_list[[i]] <- curr_df
}
i
unique_groups
month_df_list[1]
check <- month_df_list[[1]]
View(check)
ccol_indexes1,ccol_indexes2
proj_dir <- "/Users/lucasliu/Desktop/DrChen_Projects/ReCAPSE_Project/"
data_dir <- paste0(proj_dir,"/ReCAPSE_Intermediate_Data/0318_21/For_Both_Data/")
month_data <- read.csv(paste0(data_dir, "diag_monthly_df.csv"))
month_data <- month_data[,-5] #remove Na code columns
length(unique(month_data$ID)) #510
nrow(month_data) #39180
table(month_data$outcome) #0:1985309, 1:110121
nonrecurrent_pts_data <- month_data[which(month_data$outcome == 0),]
recurrent_pts_data <- month_data[which(month_data$outcome == 1),]
#Select the groups that match or exceed the threshold of the fraction of patients with at least one code in that group;
#the nonrecurrent patient thresholds are 0.15, 0.15, and 0.05,
#and the recurrent patient thresholds are 0.10, 0.10, and 0.01 for the diagnostic, procedure, and drug groups
perc_pts <- NA
analysis_data <- recurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
ccol_indexes1 <- which(perc_pts > 0.05)
perc_pts <- NA
analysis_data <- nonrecurrent_pts_data
for (j in 4:length(analysis_data)){
curr_col <- analysis_data[,j]
n_pts <- length(which(curr_col >= 1)) #n of pts have at least one code in this group
perc_pts[j] <- n_pts/nrow(analysis_data)
}
ccol_indexes2 <- which(perc_pts > 0.05)
comb_indexes <- unique(ccol_indexes1,ccol_indexes2)
comb_indexes
comb_filtered_data <- month_data[,c(1,2,3,comb_indexes)]
View(comb_filtered_data)
##########START HERE##########
########################################################################################################
###############              Data preprocessing
###############     Note: Make sure label range: [0,num_class-1]
########################################################################################################
data_input <- comb_filtered_data
#split train and test
set.seed(123)
sample <- sample.split(data_input,SplitRatio = 0.8) # 0.8 for training
library(caTools)
sample <- sample.split(data_input,SplitRatio = 0.8) # 0.8 for training
train_data <- subset(data_input,sample ==TRUE)
external_validation_data <- subset(data_input, sample==FALSE)
table(train_data$outcome)
table(external_validation_data$outcome)
73445 /1323509
36676 /661800
########################################################################################################
############               Final run
########################################################################################################
##User input Pamameters
label_col_name <- "outcome"
features_to_select <- colnames(data_input)[4:6]
n_class <- 2
important_weight_threshold <- 0.2
top_feature_flag <- 1
upsample_flag <- 1
num_rounds <- 10
num_sampling <- 5
#For multi-class classification #for multi-class, num_class needs to be specified:
#xgb_params <- list(booster = "gbtree","objective" = "multi:softmax",num_class = n_class)
#For binary classification:
xgb_params <- list(booster = "gbtree","objective" = "reg:logistic")
##LOOCV
LOOCV_res<-main_func(train_data,features_to_select,label_col_name, top_feature_flag,important_weight_threshold,upsample_flag,num_sampling,xgb_params,num_rounds)
importantce_Matrix<-LOOCV_res[[1]]
LOOCV_AVG_performance<-round(LOOCV_res[[2]],2)
critical_features <- LOOCV_res[[3]]
#Print LOOCV performance
print(LOOCV_AVG_performance)
#'This is code to generalize XGboost Classficaition
#' and train/validation with sampling method
#'Code developed by Lucas (Jing) Liu @ Univeristy of Kentucky
#'Date: 09/06/2020
#'Updated 09/10/20  : Add functions for external validation
#' @MainFunctionInput:
# 1. Data Input: Rows are IDs(rownames),
#                Columns are features,
#                Label must be in [0, num_class)
# 2. features_to_select: list of features and label for the model
# 3. label_col_name: name of label column
# 4. top_feature_flag: 1 for only using top features, 0 for using all features for validation
# 5. important_weight_threshold: threshold weight for selecting top features (Linear coeff for regression, info gain for classification)
# 6.  upsample_flag:  1 for upsampling, 0 for downsampling, others for nosampling for modeling
# 7.  num_sampling:   N of times for sampling
# 8.  xgb_params:  list of paramters: booster,Objective,etc (etc: any paramters in XGBoost document)
#    A. Choose classifer: booster = "gbtree", booster = "gblinear"
#       a .if gbtree, gain is the metric for importance  (nonlinear relations)
#       b. if gblinear, weight is the metric for importance (Linear relations)
#   B.Choose Objective function:
#     a.  Regression Model:          "objective" = "reg:squarederror" #output prediction value of label col
#     b.  Binary classification:      "objective" = "reg:logistic" #output probability
#     c.  Multi-class classification: "objective" = "multi:softmax" #output classificaiton label
# 9.  num_rounds:  N of rounds for boosting
#' Additional @main_external_FunctionInput:
#' validation_data: external validation data
#' important_features: found from main_func
#'
library(datasets)
library(xgboost)
library(ggplot2)
library(pROC)
library(openxlsx)
library(dplyr)
library(caTools)
source("XGBUtilities.R")
####MAIN Functions:
#This function returns 1. importance matrix
#                      2. LOOCV performance
#                      3. Critical features
main_func<-function(data_input,features_to_select,label_col_name, top_feature_flag,important_weight_threshold,upsample_flag,num_sampling,xgb_params,num_rounds){
#reorder "Label column to the end"
analysisdata <- data_input[,features_to_select]
analysisdata <- analysisdata %>% select(-label_col_name,label_col_name)
#Rank in imporatnce matrix
importantce_Matrix<- Find_ImportanceRank_func(analysisdata,label_col_name,xgb_params,num_rounds,upsample_flag)
important_features <- Find_critical_features_func(xgb_params,importantce_Matrix,important_weight_threshold)
#Validate important features
if(top_feature_flag==1){ #use only important features
LOOCV_validation_data<-analysisdata[,c(important_features,label_col_name)]
}else{
LOOCV_validation_data<-analysisdata
}
predict_acutal_table_list<-Validation_function(LOOCV_validation_data,label_col_name,xgb_params,num_rounds,upsample_flag,num_sampling)
performace_table_list<-list()
for(r in 1:length(predict_acutal_table_list)){
current_predict_df<-predict_acutal_table_list[[r]]
actual<-current_predict_df$actual
predicted<-current_predict_df$pred #original prediciton
#Check if multi-class or binary class classification
curr_task <- xgb_params$objective
if (curr_task == "multi:softmax"){ #perforamnce with no AUC
performace_table_list[[r]] <- compute_multiclass_perf_func(predicted,actual)
}else{
performace_table_list[[r]] <- compute_binaryclass_perf_func(predicted,actual)
}
}
performance_table_all<-do.call(rbind,performace_table_list)
performance_table_AVG_5DS<-colMeans(performance_table_all,na.rm = T) #average of sampling times
performance_table_AVG_5DS
return(list(importantce_Matrix,performance_table_AVG_5DS,important_features))
}
#This function is for prediction of external validation
#returns average performance and predicted values
main_external_func<-function(train_data,validation_data,features_to_select,label_col_name, top_feature_flag,important_features,upsample_flag,num_sampling,xgb_params,num_rounds){
#reorder "Label column to the end"
train_data <- train_data[,features_to_select]
train_data <- train_data %>% select(-label_col_name,label_col_name)
validation_data <- validation_data[,features_to_select]
validation_data <- validation_data %>% select(-label_col_name,label_col_name)
#Validate important features
if(top_feature_flag==1){ #use only important features
validation_data <- validation_data[,c(important_features,label_col_name)]
train_data <- train_data[,c(important_features,label_col_name)]
}else{
validation_data <-  validation_data
train_data <- train_data
}
#External Validation
predict_acutal_table_list_ext <- External_Validation_function(validation_data,train_data,label_col_name,upsample_flag,num_sampling)
performace_table_list_ext <- compute_performance_function(predict_acutal_table_list_ext)
perf_tb_all_ext<-do.call(rbind,performace_table_list_ext)
perf_tb_AVG_5DS_ext<-colMeans(perf_tb_all_ext,na.rm = T) #average of sampling times
perf_tb_AVG_5DS_ext
return(list(perf_tb_AVG_5DS_ext,predict_acutal_table_list_ext))
}
label_col_name <- "outcome"
features_to_select <- colnames(data_input)[4:6]
n_class <- 2
important_weight_threshold <- 0.2
top_feature_flag <- 1
upsample_flag <- 1
num_rounds <- 10
num_sampling <- 5
#For multi-class classification #for multi-class, num_class needs to be specified:
#xgb_params <- list(booster = "gbtree","objective" = "multi:softmax",num_class = n_class)
#For binary classification:
xgb_params <- list(booster = "gbtree","objective" = "reg:logistic")
##LOOCV
LOOCV_res<-main_func(train_data,features_to_select,label_col_name, top_feature_flag,important_weight_threshold,upsample_flag,num_sampling,xgb_params,num_rounds)
importantce_Matrix<-LOOCV_res[[1]]
LOOCV_AVG_performance<-round(LOOCV_res[[2]],2)
critical_features <- LOOCV_res[[3]]
#Print LOOCV performance
print(LOOCV_AVG_performance)
##LOOCV
LOOCV_res<-main_func(train_data,features_to_select,label_col_name, top_feature_flag,important_weight_threshold,upsample_flag,num_sampling,xgb_params,num_rounds)
comb_filtered_data$outcome
########################################################################################################
############               Final run
########################################################################################################
##User input Pamameters
label_col_name <- "outcome"
features_to_select <- colnames(data_input)[3:6]
n_class <- 2
important_weight_threshold <- 0.2
top_feature_flag <- 1
upsample_flag <- 1
num_rounds <- 10
num_sampling <- 5
#For multi-class classification #for multi-class, num_class needs to be specified:
#xgb_params <- list(booster = "gbtree","objective" = "multi:softmax",num_class = n_class)
#For binary classification:
xgb_params <- list(booster = "gbtree","objective" = "reg:logistic")
##LOOCV
LOOCV_res<-main_func(train_data,features_to_select,label_col_name, top_feature_flag,important_weight_threshold,upsample_flag,num_sampling,xgb_params,num_rounds)
importantce_Matrix<-LOOCV_res[[1]]
LOOCV_AVG_performance<-round(LOOCV_res[[2]],2)
critical_features <- LOOCV_res[[3]]
